Considera il modulo Ground_Weapon_Data.py, il tuo compito è valutare ed implementare le informazioni mancanti in alcune armi specificate nel dizionario GROUND_WEAPONS e implementare la funzione calc_weapon_efficiency che restituisce un valore che rappresenta il livello di efficacia di una specifica arma calcolato in base alla tipologia di target, alle dimensioni degli asset che costituiscono l'obiettivo.

Nello specifico dovresti valutare e implementare le informazioni per i dizionari 'task', 'efficiency' e il valore di 'perc_efficiency_variability'.

Come riferimento per le strutture dati di 'task', 'efficiency' e 'perc_efficiency_variability' considera quelle implementate nel dizionario '2A46M' contenuto in GROUND_WEAPON.

'task' rappresenta i task in cui l'arma può essere utilizzata. I valori ammissibili sono specificati nel dizionario GROUND_WEAPON_TASK implementato in Context.py.

'efficiency' rappresenta l'efficienza delle armi riguardo differenti bersagli ('Soft', 'Armored', 'Hard', ....) e alle dimensioni degli asset da cui è composto l'obiettivo ('big', 'med' e 'small'). 
La struttura dei dati da considerare per 'efficiency' è quella definita nel dizionario 'efficiency' contenuto nel dizionario '2A46M' a sua volta contenuto in GROUND_WEAPON. 
Nel dizionario 'efficiency', per ogni tipologia di obiettivo ('Soft', 'Armored', 'Hard', ....) e in relazione alle dimensioni degli asset di cui è composto il bersaglio ('big', 'med' e 'small'), sono specificate le seguenti proprietà: 'accuracy' cioè il livello di precisione nel colpire quel tipo di bersaglio e 'destroy_capacity' cioè la capacità distruttiva rappresentata, indicativamente, da una stima della quantità di singoli asset che l'arma distrugge al singolo utilizzo o ad ogni colpo. 
'accuracy' varia da 0: nessuna precisione nel colpire il bersaglio a 1: precisione assoluta nel colpire il bersaglio (il bersaglio viene sicuramente colpito con l'utilizzo dell'arma). 'destroy_capacity' varia da sys.float_info.min fino al numero di asset del bersaglio che un singolo colpo o la singola arma è in grado di distruggere.

'perc_efficiency_variability' varia da 0 a 1 e rappresenta la percentuale di variabilità da applicare successivamente al valore di 'efficiency' che verrà calcolato in base ai due parametri 'accuracy' e 'destroy_capacity': 0 nessuna variabilità, il valore di 'efficiency' è quello calcolato, 1: variabilità massima, il valore di 'efficiency' calcolato può variare casualmente da 0 fino al valore stabilito in 'perc_efficiency_variability' .

In base a quanto sopra detto: 
1 - implementa i dizionari 'task', 'efficiency' e il valore di 'perc_efficiency_variability' valutando le informazioni necessarie per tutte le armi specificate nel dizionario GROUND_WEAPONS revisionando anche i valori specificati per il dizionario '2A46M'. Per le tue valutazioni utilizza le informazioni disponibili in internet sulle armi da considerare e gli effetti di queste sugli asset di riferimento. La descrizione degli asset di riferimento che costituiscono un obiettivo è specificata nel dizionario TARGET_CLASSIFICATION implementato in Context.py. Nella implementazione non includere la dimensione 'mix' presente nei dati di GROUND_WEAPONS.

2 - implementa nel modulo Ground_Weapon_Data la funzione calc_weapon_efficiency(weapon_type: str, weapon_model: str, target_type, target_dimension_distribuition: dict): float. L'argomento asset_dimension_distribuition della funzione è un dizionario contenente le percentuali delle dimensioni delle dimensioni degli asset che costituiscono l'obiettivo, esempio: {'big': 0.1, med: 0.6, low: 0.3}. 
La funzione restituisce un valore float calcolato in base ai valori di 'accuracy' e 'destroy_capacity' specificati nel dizionario efficiency contenuto in GROUND_WEAPONS per ogni arma, in relazione alle dimensioni degli asset costituenti l'obiettivo ("big", "med", ...), alla tipologia di target ("soft", "hard", ... ) e applicando il fattore di variabilità valutato casualmente tra 0 e 'perc_efficiency_variability'. Nella implementazione non includere la dimensione 'mix' presente nei dati di GROUND_WEAPONS.

Per quanto riguarda la valutazione delle dimensioni dell'asset in base alla classificazione con: 'big', 'med' e 'small', considera i seguenti aspetti: 
- Soft: rappresentano obiettivi costituiti prevalentemente da mezzi (veicoli, aeromobili) militari senza particolari protezioni dove la variazione delle dimensioni non influisce significativamente nella resistenza all'arma
- Armored, Air_Defense: rappresentano obiettivi costituiti prevalentemente da mezzi (veicoli, aeromobili) militari con particolari protezioni dove la variazione delle dimensioni non influisce significativamente nella resistenza all'arma mentre la protezione si.
- Hard, Structure: rappresentano obiettivi costituiti prevalentemente da costruzioni, edifici, strutture industriali dove la variazione delle dimensioni influisce significativamente nella resistenza all'arma. Gli obiettivi 'Hard' sono più resistenti all'arma per le caratteristiche costruttive degli asset o per una specifica protezione.
- Airbase, Port, Shipyard, Farp, Stronghold: rappresentano obiettivi costituiti da costruzioni, edifici, strutture industriali dove la variazione delle dimensioni influisce significativamente nella resistenza all'arma e da mezzi (veicoli, aeromobili, navi) militari dove la variazione delle dimensioni non influisce significativamente nella resistenza all'arma. 
- Ship: rappresentano obiettivi costituiti da navi prevalentemente militari e alcune navi civili. Per questi obiettivi la tipologia di nave e la sua dimensione influisce significativamente nella resistenza all'arma.


Aggiornamento da richiedere a claude per la funzione Ground_Weapon_Data.alc_weapon_efficiency:
Nella precedente sessione di lavoro, durante l'implementazione della funzione calc_weapon_efficiency nel modulo Ground_Weapon_Data.py,  hai effettuato un raggruppamento dei template dei dizionari di efficienza in modo che uno stesso template possa essere utilizzato per diverse armi. Puoi includere nel valore restituito dalla funzione calc_weapon_efficiency dei fattori che tengano conto anche delle differente di calibro e del tipo di munizioni usate (specificate nel dizionario 'ammo_type').     


Il problema della super valutazione del fire rate è presente anche in alcuni cannoni presenti in veicoli ARMORED, per esempio il Marder o il   
 BMP-3 che hanno weapon score (global_score) pari a 1 e 0.4410 rispetto a TANK quali il T-90M o M1A2-Abrams che hanno score di 0.1641 e 0.1449.  
 Valuta se differenziare il calcolo del  anche il tipo di cannoni montato su questi veicoli considerando il calibro     
 
Realizza il modulo di test Test_Ground_Weapon_Data.py basato sulla libreria unittest, nel quale sono implementati i test di unità per tutte le funzioni e la verifica delle strutture dati implementate del modulo Ground_Weapon_Data.py. Inoltre, deve essere implementato il codice per la stampa a terminale ed in pdf delle seguenti tabelle:
- tabella di confronto del punteggio, calcolato con la funzione get_weapon_score(), per tutte le armi appartenenti ad una determinata categoria di arma (Cannoni, Artiglieria, Missili, ....). Le categorie di armi in base alle quali effettuare le stampe devono essere specificate in una lista modificabile: weapon_type = ["CANNONS", "MISSILES", "ARTILLERY", ...]. 
- tabella di confronto del punteggio, calcolato con la funzione get_weapon_score_target(), per tutte le armi appartenenti ad una determinata categoria di arma (Cannoni, Artiglieria, Missili, ....) e in base alle caratteristiche del target impostate mediante due liste modificabili (target_type = ["Soft", "Armored", ...] e target_dimension = ["big", "small", ...]. Le categorie di armi in base alle quali effettuare le stampe devono essere specificate in una lista modificabile: weapon_type = ["CANNONS", "MISSILES", "ARTILLERY", ...]. Considera come riferimento non vincolante, quanto realizzato nella funzione Test_Aircraft_Weapon_Data.py


Ho implementato le funzioni get_weapon e get_weapon_score_target nel modulo Ground_Weapon_Data.py. Implementa i test di unità per queste due funzioni nel modulo Test_Ground_Weapon_Data.py e implementa il codice per la stampa a terminale ed in pdf per la seguente tabella:
- tabella di confronto del punteggio, calcolato con la funzione get_weapon_score_target(), per tutte le armi appartenenti ad una determinata categoria di arma (Cannoni, Artiglieria, Missili, ....) e in base alle caratteristiche del target impostate mediante due liste modificabili (target_type = ["Soft", "Armored", ...] e target_dimension = ["big", "small", ...]. Le categorie di armi in base alle quali effettuare le stampe devono essere specificate in una lista modificabile: weapon_type = ["CANNONS", "MISSILES", "ARTILLERY", ...]. 
 

Nel modulo Vehicle_Data.py implementa le funzioni: 
 - _weapon_target_effectiveness(self, target_type: List, target_dimension: List) -> float
 - get_normalized_weapon_target_effectiveness(self, target_type: List, target_dimension: List) -> float
 
 La funzione _weapon_target_effectiveness sviuluppala in modo analogo alla funzione loadout_target_effectiveness implementata nel modulo Aircraft_Loadouts.py, la funzione get_normalized_weapon_target_effectiveness in modo analogo alle altre funzioni normalizzate presenti in Vehicle_Data.py   



Considerando quanto realizzato nel modulo di test: Test_Ground_Weapon_Data.py 
